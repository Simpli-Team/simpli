// ============================================================================
// Simpli Framework - Sidebar Generator
// ============================================================================
// Generates sidebar navigation from file system structure.
// Supports:
//   - Auto-generation from directory structure
//   - Manual config override & merge
//   - _category_.json metadata for categories
//   - Frontmatter-based ordering (sidebar_position)
//   - Nested categories (unlimited depth)
//   - Mixed auto + manual sections
//   - Collapsible categories
// ============================================================================

import fs from 'node:fs';
import path from 'node:path';
import type { SidebarItem, SidebarCategoryItem, SidebarsConfig } from '../config/types';
import { parseFrontmatter } from '../content/FrontmatterParser';

interface CategoryMeta {
    label?: string;
    position?: number;
    collapsed?: boolean;
    collapsible?: boolean;
    className?: string;
    description?: string;
    link?: {
        type: 'doc' | 'generated-index';
        id?: string;
        title?: string;
        description?: string;
        slug?: string;
    };
}

interface FileEntry {
    name: string;
    fullPath: string;
    isDirectory: boolean;
    position?: number;
    label?: string;
}

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Generate complete sidebar configuration.
 * If user provides sidebars config, resolve 'autogenerated' items.
 * Otherwise, auto-generate entirely from file system.
 */
export function generateSidebar(
    docsDir: string,
    userSidebars?: SidebarsConfig,
): SidebarsConfig {
    if (!fs.existsSync(docsDir)) {
        return {};
    }

    // If user provided sidebars, resolve autogenerated sections
    if (userSidebars && Object.keys(userSidebars).length > 0) {
        return resolveUserSidebars(userSidebars, docsDir);
    }

    // Auto-generate from file system
    return {
        docs: autogenerateSidebar(docsDir, docsDir),
    };
}

// ---------------------------------------------------------------------------
// Auto-generation from file system
// ---------------------------------------------------------------------------

/**
 * Recursively build sidebar items from a directory.
 */
function autogenerateSidebar(dir: string, rootDocsDir: string): SidebarItem[] {
    const entries = getDirectoryEntries(dir);
    const items: SidebarItem[] = [];

    for (const entry of entries) {
        if (entry.isDirectory) {
            // Generate category from subdirectory
            const category = buildCategory(entry, rootDocsDir);
            if (category) {
                items.push(category);
            }
        } else {
            // Generate doc item from file
            const docItem = buildDocItem(entry, rootDocsDir);
            if (docItem) {
                items.push(docItem);
            }
        }
    }

    // Sort by position, then alphabetically
    return sortSidebarItems(items);
}

/**
 * Build a category from a directory.
 */
function buildCategory(
    entry: FileEntry,
    rootDocsDir: string,
): SidebarCategoryItem | null {
    const categoryMeta = loadCategoryMeta(entry.fullPath);
    const childItems = autogenerateSidebar(entry.fullPath, rootDocsDir);

    // Skip empty categories
    if (childItems.length === 0) return null;

    // Check for index file in category
    const indexFile = findIndexFile(entry.fullPath);
    let link: SidebarCategoryItem['link'] | undefined;

    if (indexFile) {
        const relativePath = path
            .relative(rootDocsDir, indexFile)
            .replace(/\\/g, '/')
            .replace(/\.(mdx?|tsx?)$/, '')
            .replace(/\/index$/, '')
            .split('/')
            .map(stripNumericPrefix)
            .join('/');

        link = {
            type: 'doc',
            id: relativePath || stripNumericPrefix(entry.name),
        };
    }

    return {
        type: 'category',
        label: categoryMeta?.label ?? formatLabel(entry.name),
        collapsed: categoryMeta?.collapsed ?? true,
        collapsible: categoryMeta?.collapsible ?? true,
        className: categoryMeta?.className,
        items: childItems,
        link,
    };
}

/**
 * Build a doc item from a file.
 */
function buildDocItem(
    entry: FileEntry,
    rootDocsDir: string,
): SidebarItem | null {
    const ext = path.extname(entry.name);
    if (!['.mdx', '.md'].includes(ext)) return null;

    // Skip index files (they become category links)
    if (entry.name.replace(ext, '') === 'index') return null;

    // Parse frontmatter to get metadata
    const content = fs.readFileSync(entry.fullPath, 'utf-8');
    const { frontmatter } = parseFrontmatter(content);

    const fileNameWithoutExt = entry.name.replace(ext, '');
    const relativePath = path
        .relative(rootDocsDir, entry.fullPath)
        .replace(/\\/g, '/')
        .replace(/\.(mdx?|tsx?)$/, '')
        .split('/')
        .map(stripNumericPrefix)
        .join('/');

    // Strip numeric prefix from display
    const cleanName = stripNumericPrefix(fileNameWithoutExt);

    return {
        type: 'doc',
        id: relativePath,
        label: frontmatter.sidebar_label ?? frontmatter.title ?? formatLabel(cleanName),
        className: undefined,
    };
}

// ---------------------------------------------------------------------------
// User sidebar resolution (handles 'autogenerated' type)
// ---------------------------------------------------------------------------

/**
 * Resolve user-defined sidebars: expand any { type: 'autogenerated' } items.
 */
function resolveUserSidebars(
    sidebars: SidebarsConfig,
    docsDir: string,
): SidebarsConfig {
    const resolved: SidebarsConfig = {};

    for (const [key, items] of Object.entries(sidebars)) {
        resolved[key] = resolveItems(items, docsDir);
    }

    return resolved;
}

function resolveItems(items: SidebarItem[], docsDir: string): SidebarItem[] {
    const result: SidebarItem[] = [];

    for (const item of items) {
        if (typeof item === 'string') {
            // Shorthand doc ID
            result.push(item);
            continue;
        }

        if (item.type === 'autogenerated') {
            // Expand autogenerated section
            const targetDir = path.resolve(docsDir, item.dirName);
            if (fs.existsSync(targetDir)) {
                const generated = autogenerateSidebar(targetDir, docsDir);
                result.push(...generated);
            }
            continue;
        }

        if (item.type === 'category') {
            // Recursively resolve children
            result.push({
                ...item,
                items: resolveItems(item.items, docsDir),
            });
            continue;
        }

        result.push(item);
    }

    return result;
}

// ---------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------

/**
 * Get sorted directory entries (directories first, then files).
 */
function getDirectoryEntries(dir: string): FileEntry[] {
    if (!fs.existsSync(dir)) return [];

    return fs
        .readdirSync(dir, { withFileTypes: true })
        .filter((e) => {
            // Skip hidden files, node_modules, and category meta files
            if (e.name.startsWith('.')) return false;
            if (e.name === 'node_modules') return false;
            if (e.name === '_category_.json') return false;
            if (e.name === '_category_.yml') return false;
            return true;
        })
        .map((e) => {
            const fullPath = path.join(dir, e.name);
            let position: number | undefined;
            let label: string | undefined;

            // Extract position from numeric prefix (e.g. "01-intro.mdx")
            const numMatch = e.name.match(/^(\d+)-/);
            if (numMatch) {
                position = parseInt(numMatch[1], 10);
            }

            // For files, try to get position from frontmatter
            if (e.isFile() && (e.name.endsWith('.mdx') || e.name.endsWith('.md'))) {
                try {
                    const content = fs.readFileSync(fullPath, 'utf-8');
                    const { frontmatter } = parseFrontmatter(content);
                    if (frontmatter.sidebar_position !== undefined) {
                        position = frontmatter.sidebar_position;
                    }
                    if (frontmatter.sidebar_label) {
                        label = frontmatter.sidebar_label;
                    }
                } catch {
                    // Ignore parse errors
                }
            }

            // For directories, try to get position from category meta
            if (e.isDirectory()) {
                const meta = loadCategoryMeta(fullPath);
                if (meta?.position !== undefined) {
                    position = meta.position;
                }
                if (meta?.label) {
                    label = meta.label;
                }
            }

            return {
                name: e.name,
                fullPath,
                isDirectory: e.isDirectory(),
                position,
                label,
            };
        })
        .sort((a, b) => {
            // Directories before files
            if (a.isDirectory !== b.isDirectory) {
                return a.isDirectory ? -1 : 1;
            }
            // Then by position
            const posA = a.position ?? Infinity;
            const posB = b.position ?? Infinity;
            if (posA !== posB) return posA - posB;
            // Then alphabetically
            return a.name.localeCompare(b.name);
        });
}

/**
 * Sort sidebar items by position metadata.
 */
function sortSidebarItems(items: SidebarItem[]): SidebarItem[] {
    return items.sort((a, b) => {
        const posA = getSidebarItemPosition(a);
        const posB = getSidebarItemPosition(b);
        if (posA !== posB) return posA - posB;

        const labelA = getSidebarItemLabel(a);
        const labelB = getSidebarItemLabel(b);
        return labelA.localeCompare(labelB);
    });
}

function getSidebarItemPosition(item: SidebarItem): number {
    if (typeof item === 'string') return Infinity;
    // Position is determined during building, not stored in the item type
    return Infinity;
}

function getSidebarItemLabel(item: SidebarItem): string {
    if (typeof item === 'string') return item;
    if (item.type === 'autogenerated') return item.dirName;
    return 'label' in item ? (item.label ?? '') : '';
}

/**
 * Load _category_.json from a directory.
 */
function loadCategoryMeta(dir: string): CategoryMeta | null {
    const filePath = path.join(dir, '_category_.json');
    if (!fs.existsSync(filePath)) return null;

    try {
        return JSON.parse(fs.readFileSync(filePath, 'utf-8'));
    } catch {
        console.warn(`[simpli:sidebar] Failed to parse ${filePath}`);
        return null;
    }
}

/**
 * Find an index file in a directory.
 */
function findIndexFile(dir: string): string | null {
    const candidates = ['index.mdx', 'index.md'];
    for (const candidate of candidates) {
        const fullPath = path.join(dir, candidate);
        if (fs.existsSync(fullPath)) return fullPath;
    }
    return null;
}

/**
 * Strip numeric prefix from filename: "01-getting-started" → "getting-started"
 */
function stripNumericPrefix(name: string): string {
    return name.replace(/^\d+-/, '');
}

/**
 * Format a file/directory name as a readable label.
 * "getting-started" → "Getting Started"
 */
function formatLabel(name: string): string {
    return stripNumericPrefix(name)
        .replace(/[-_]/g, ' ')
        .replace(/\b\w/g, (c) => c.toUpperCase());
}
